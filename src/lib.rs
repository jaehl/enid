//! An **ENID** (Encrypted Numeric Identifier) is a 40- or 80-bit value, which can
//! be used as a unique identifier.
//!
//! An example of a 40-bit ENID:
//!
//! ```text
//! m6sc7n75
//! ```
//!
//! And an 80-bit ENID:
//!
//! ```text
//! y3gx5gxm-mpb8ey39
//! ```
//!
//! ENIDs are generated by encrypting plaintext bytes so that they appear
//! pseudo-random. The encrypted bytes are then formatted as a variant of Base32
//! (Crockford's Base32) that excludes the letters `i`, `l`, `o`, and `u`. Each
//! group of 40 bits is represented by 8 characters and separated by a hyphen.
//!
//! This crate does not yet include a method for generating ENIDs, which will be
//! added in a future version.
//!
//! Some features of ENIDs:
//!
//! * Short - ENIDs are 8 or 17 characters long, compared with 36-character UUIDs.
//! * Uniformly distributed - sequentially-generated ENIDs are unlikely to appear
//!   similar.
//! * URL-safe - ENIDs can be used in URLs without percent-encoding.
//!
//! # Crate features
//!
//! * `arbitrary` - adds [`Arbitrary`](arbitrary::Arbitrary) implementations for
//!   fuzzing.
//! * `borsh` - adds serialization and deserialization via [`borsh`].
//! * `bytemuck` - adds [`Pod`](bytemuck::Pod) implementations for byte
//!   manipulation.
//! * `serde` - adds serialization and deserialization via [`serde`].
//! * `slog` - adds [`Value`](slog::Value) implementations for serialization.

#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]

#[cfg(test)]
extern crate std;

mod base32;
mod enid;
mod external;

pub use self::enid::{Enid, Enid40, Enid80, EnidParseError};

/// Creates an [`Enid40`] by parsing the given string at compile-time.
///
/// An invalid ENID string will cause a compilation error.
///
/// # Examples
///
/// Parsing an ENID at compile-time:
///
/// ```
/// # use enid::{enid40, Enid40};
/// const ENID: Enid40 = enid40!("m6sc7n75");
/// ```
///
/// An invalid ENID will not compile:
///
/// ```compile_fail
/// # use enid::{enid40, Enid40};
/// const ENID: Enid40 = enid40!("iisc7n75");
/// ```
#[macro_export]
macro_rules! enid40 {
    ($s:expr) => {{
        const ENID: $crate::Enid40 = match $crate::Enid40::parse_str($s) {
            Ok(enid) => enid,
            Err(_) => panic!("invalid ENID"),
        };
        ENID
    }};
}

/// Creates an [`Enid80`] by parsing the given string at compile-time.
///
/// An invalid ENID string will cause a compilation error.
///
/// # Examples
///
/// Parsing an ENID at compile-time:
///
/// ```
/// # use enid::{enid80, Enid80};
/// const ENID: Enid80 = enid80!("y3gx5gxm-mpb8ey39");
/// ```
///
/// An invalid ENID will not compile:
///
/// ```compile_fail
/// # use enid::{enid80, Enid80};
/// const ENID: Enid80 = enid80!("iigx5gxm-mpb8ey39");
/// ```
#[macro_export]
macro_rules! enid80 {
    ($s:expr) => {{
        const ENID: $crate::Enid80 = match $crate::Enid80::parse_str($s) {
            Ok(enid) => enid,
            Err(_) => panic!("invalid ENID"),
        };
        ENID
    }};
}

/// Creates an [`Enid`] by parsing the given string at compile-time.
///
/// An invalid ENID string will cause a compilation error.
///
/// # Examples
///
/// Parsing an ENID at compile-time:
///
/// ```
/// # use enid::{enid, Enid};
/// const ENID_40: Enid = enid!("m6sc7n75");
/// const ENID_80: Enid = enid!("y3gx5gxm-mpb8ey39");
/// ```
///
/// An invalid ENID will not compile:
///
/// ```compile_fail
/// # use enid::{enid, Enid};
/// const ENID: Enid = enid!("iisc7n75");
/// ```
#[macro_export]
macro_rules! enid {
    ($s:expr) => {{
        const ENID: $crate::Enid = match $crate::Enid::parse_str($s) {
            Ok(enid) => enid,
            Err(_) => panic!("invalid ENID"),
        };
        ENID
    }};
}
